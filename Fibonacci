# --- AdvancedFibonacciStrategy (Fixed & BTC/USDT‑tuned) ---
# Copy‑paste into user_data/strategies/AdvancedFibonacciStrategy.py
# Freqtrade >= 2024.x (tested on 2025.x API surface)
#
# Tailored defaults target BTC/USDT on 15m; hyperopt ranges provided as Parameters.

from functools import reduce
from typing import Dict, List, Tuple, Optional
from datetime import datetime

import numpy as np
import pandas as pd
from pandas import DataFrame

from freqtrade.strategy.interface import IStrategy
from freqtrade.strategy import (
    IntParameter,
    DecimalParameter,
    RealParameter,
    BooleanParameter,
    merge_informative_pair,
)
from freqtrade.strategy import stoploss_from_open

import talib.abstract as ta


class AdvancedFibonacciStrategy(IStrategy):
    """
    Advanced Fibonacci Pullback (BTC/USDT 15m)

    Buy pullbacks to Fibonacci support within an uptrend (EMA20>EMA50) when RSI is cool;
    sell into Fibonacci resistance or BB extremes when RSI is hot. Adds multi‑timeframe
    confluence (1h/4h EMAs and optional Fib proximity), stricter volume context, and a
    volatility‑aware dynamic stop based on ATR.
    """

    INTERFACE_VERSION = 3

    # --- Core market settings
    timeframe = "15m"
    can_short: bool = False

    # We use informative timeframes for confluence
    informative_timeframes = ["1h", "4h"]

    # --- Risk / ROI / Trailing (BTC‑tuned)
    # Smaller, realistic 15m ROI ladder for BTC. Still combine with exits & trailing.
    minimal_roi = {
        "120": 0.003,  # after 120 min, accept 0.3%
        "60": 0.006,   # after 60 min, 0.6%
        "30": 0.010,   # after 30 min, 1.0%
        "0": 0.014,    # immediately require 1.4%
    }

    # Base emergency stop (won't be tighter than this). Dynamic ATR stop may be looser.
    stoploss = -0.035  # -3.5%

    # Trailing: start early for BTC pops
    trailing_stop = True
    trailing_stop_positive = 0.007        # trail by 0.7%
    trailing_stop_positive_offset = 0.012 # start trailing once >= +1.2%
    trailing_only_offset_is_reached = True

    process_only_new_candles = True

    use_exit_signal = True
    exit_profit_only = False
    ignore_roi_if_entry_signal = False

    # Ensure enough data (for longest HTF calc). 400 is a safe buffer.
    startup_candle_count: int = 400

    # --- Hyperoptable parameters (BTC‑centric defaults)
    # Fib lookback on 15m
    fib_period_15m = IntParameter(34, 72, default=54, space="buy")
    # How close price must be to a Fib level (±tolerance)
    fib_tolerance = DecimalParameter(0.015, 0.03, default=0.02, decimals=3, space="buy")

    # RSI config
    rsi_period = IntParameter(10, 20, default=14, space="buy")
    rsi_oversold = IntParameter(35, 50, default=42, space="buy")
    rsi_overbought = IntParameter(58, 70, default=62, space="sell")

    # Trend & volume context
    vol_window = IntParameter(30, 80, default=50, space="buy")
    vol_ratio_min = DecimalParameter(1.0, 1.5, default=1.1, decimals=2, space="buy")

    # ATR dynamic stop parameters
    atr_period = IntParameter(10, 28, default=14, space="sell")
    atr_mult = RealParameter(3.0, 5.0, default=3.5, space="sell")

    # Order types / TIF
    order_types = {
        "entry": "limit",
        "exit": "limit",
        "stoploss": "market",
        "stoploss_on_exchange": False,
    }

    order_time_in_force = {
        "entry": "GTC",
        "exit": "GTC",
    }

    # --------------- Helpers
    @staticmethod
    def _compute_fibs(df: DataFrame, period: int) -> DataFrame:
        df["rolling_high"] = df["high"].rolling(window=period, min_periods=period).max()
        df["rolling_low"] = df["low"].rolling(window=period, min_periods=period).min()
        df["price_range"] = df["rolling_high"] - df["rolling_low"]
        # Fibonacci retracements from the recent range high
        df["fib_0_236"] = df["rolling_high"] - 0.236 * df["price_range"]
        df["fib_0_382"] = df["rolling_high"] - 0.382 * df["price_range"]
        df["fib_0_5"]   = df["rolling_high"] - 0.5   * df["price_range"]
        df["fib_0_618"] = df["rolling_high"] - 0.618 * df["price_range"]
        df["fib_0_786"] = df["rolling_high"] - 0.786 * df["price_range"]
        return df

    @staticmethod
    def _bbands(df: DataFrame, period: int = 20, ndev: float = 2.0) -> Tuple[pd.Series, pd.Series, pd.Series]:
        upper, middle, lower = ta.BBANDS(df, timeperiod=period, nbdevup=ndev, nbdevdn=ndev, matype=0)
        return upper, middle, lower

    # --------------- Informative dataframes (1h, 4h)
    def informative_pairs(self):
        # Use same pair on 1h and 4h for confluence
        pairs = []
        for tf in self.informative_timeframes:
            pairs.append((self.dp.current_whitelist()[0], tf))
        return pairs

    def _build_informative(self, metadata: dict, tf: str) -> DataFrame:
        pair = metadata["pair"]
        inf = self.dp.get_pair_dataframe(pair=pair, timeframe=tf)
        # EMAs for HTF trend context
        inf["ema20"] = ta.EMA(inf, timeperiod=20)
        inf["ema50"] = ta.EMA(inf, timeperiod=50)
        # Optional: HTF fibs for proximity checks (use same period as 15m for simplicity)
        period = int(self.fib_period_15m.value)
        inf = self._compute_fibs(inf, period)
        return inf

    # --------------- Main indicators
    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # RSI
        dataframe["rsi"] = ta.RSI(dataframe, timeperiod=int(self.rsi_period.value))

        # EMAs for 15m trend
        dataframe["ema20"] = ta.EMA(dataframe, timeperiod=20)
        dataframe["ema50"] = ta.EMA(dataframe, timeperiod=50)
        dataframe["ema100"] = ta.EMA(dataframe, timeperiod=100)

        # Bollinger Bands + percent position within bands
        bb_upper, bb_mid, bb_lower = self._bbands(dataframe, period=20, ndev=2.0)
        dataframe["bb_upper"] = bb_upper
        dataframe["bb_mid"] = bb_mid
        dataframe["bb_lower"] = bb_lower
        band_width = (bb_upper - bb_lower).replace(0, np.nan)
        dataframe["bb_percent"] = (dataframe["close"] - bb_lower) / band_width

        # ATR for dynamic stop
        dataframe["atr"] = ta.ATR(dataframe, timeperiod=int(self.atr_period.value))

        # Volume context
        vwin = int(self.vol_window.value)
        dataframe["vol_sma"] = ta.SMA(dataframe[["volume"]], timeperiod=vwin)
        dataframe["vol_ratio"] = dataframe["volume"] / dataframe["vol_sma"]

        # 15m fibs
        period_15 = int(self.fib_period_15m.value)
        dataframe = self._compute_fibs(dataframe, period_15)

        # --- Merge informative frames for confluence
        for tf in self.informative_timeframes:
            inf = self._build_informative(metadata, tf)
            dataframe = merge_informative_pair(dataframe, inf, timeframe=tf, ffill=True)
            # merged columns get suffix like _1h or _4h

        return dataframe

    # --------------- Entry
    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        tol = float(self.fib_tolerance.value)

        # Price near any of the support fibs (0.786 / 0.618 / 0.5)
        near_fib_support = (
            (dataframe["price_range"] > 0) &
            (
                (dataframe["close"].between(dataframe["fib_0_786"] * (1 - tol), dataframe["fib_0_786"] * (1 + tol))) |
                (dataframe["close"].between(dataframe["fib_0_618"] * (1 - tol), dataframe["fib_0_618"] * (1 + tol))) |
                (dataframe["close"].between(dataframe["fib_0_5"]   * (1 - tol), dataframe["fib_0_5"]   * (1 + tol)))
            )
        )

        # 15m trend filter
        trend_15m = (dataframe["close"] > dataframe["ema20"]) & (dataframe["ema20"] > dataframe["ema50"])  # stronger uptrend

        # Volume context (avoid quiet chop)
        vol_ok = dataframe["vol_ratio"] >= float(self.vol_ratio_min.value)

        # RSI cool
        rsi_ok = dataframe["rsi"] <= int(self.rsi_oversold.value)

        # ---- Multi‑TF confluence (FIXED: no more "| True")
        confluence_htf = (
            (dataframe.get("ema20_1h", pd.Series(index=dataframe.index)).notna()) &
            (dataframe.get("ema50_1h", pd.Series(index=dataframe.index)).notna()) &
            (dataframe["ema20_1h"] > dataframe["ema50_1h"]) &
            (dataframe.get("ema20_4h", pd.Series(index=dataframe.index)).notna()) &
            (dataframe.get("ema50_4h", pd.Series(index=dataframe.index)).notna()) &
            (dataframe["ema20_4h"] >= dataframe["ema50_4h"])  # 4h at least neutral‑to‑up
        )

        dataframe.loc[
            (dataframe["volume"] > 0) &
            trend_15m &
            vol_ok &
            rsi_ok &
            near_fib_support &
            confluence_htf,
            "enter_long"
        ] = 1

        return dataframe

    # --------------- Exit
    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        tol = float(self.fib_tolerance.value)

        # Near Fib resistance (0.382 / 0.236 / 0.5)
        near_fib_resistance = (
            (dataframe["price_range"] > 0) &
            (
                (dataframe["close"].between(dataframe["fib_0_382"] * (1 - tol), dataframe["fib_0_382"] * (1 + tol))) |
                (dataframe["close"].between(dataframe["fib_0_236"] * (1 - tol), dataframe["fib_0_236"] * (1 + tol))) |
                (dataframe["close"].between(dataframe["fib_0_5"]   * (1 - tol), dataframe["fib_0_5"]   * (1 + tol)))
            )
        )

        # BB extreme (ride to upper band)
        bb_extreme = dataframe["bb_percent"] >= 0.9

        # RSI hot
        rsi_hot = dataframe["rsi"] >= int(self.rsi_overbought.value)

        dataframe.loc[
            (dataframe["volume"] > 0) &
            (rsi_hot) &
            (near_fib_resistance | bb_extreme),
            "exit_long"
        ] = 1

        return dataframe

    # --------------- Dynamic Stoploss (ATR floor)
    def custom_stoploss(self, pair: str, trade, current_time: datetime,
                        current_rate: float, current_profit: float, **kwargs) -> float:
        """
        Return dynamic stop based on ATR: max(base stop, -(atr_mult * ATR / price)).
        Ensures we never tighten below configured base stoploss.
        """
        try:
            df = self.dp.get_pair_dataframe(pair=pair, timeframe=self.timeframe)
            if df is None or df.empty:
                return self.stoploss
            # Use the last computed ATR from populate_indicators; if missing, compute quickly
            atr = df["atr"].iloc[-1] if "atr" in df.columns and pd.notna(df["atr"].iloc[-1]) else ta.ATR(df, timeperiod=int(self.atr_period.value)).iloc[-1]
            if pd.isna(atr) or atr <= 0 or current_rate <= 0:
                return self.stoploss
            dyn = -float(self.atr_mult.value) * (atr / float(current_rate))
            # Never tighter than the base stop
            return max(self.stoploss, float(dyn))
        except Exception:
            # Fail‑safe to base stop in any unexpected scenario
            return self.stoploss

    # --------------- Plot config (optional)
    @property
    def plot_config(self) -> Dict:
        return {
            "main_plot": {
                "ema20": {"color": "orange"},
                "ema50": {"color": "blue"},
                "bb_upper": {"color": "grey"},
                "bb_mid": {"color": "lightgrey"},
                "bb_lower": {"color": "grey"},
                "fib_0_236": {"color": "#ff6b6b"},
                "fib_0_382": {"color": "#ffa94d"},
                "fib_0_5":   {"color": "#ffd43b"},
                "fib_0_618": {"color": "#51cf66"},
                "fib_0_786": {"color": "#339af0"},
            },
            "subplots": {
                "RSI": {
                    "rsi": {"color": "purple"},
                },
                "Volume": {
                    "vol_ratio": {"color": "teal"},
                },
                "BB%": {
                    "bb_percent": {"color": "black"},
                },
            },
        }
